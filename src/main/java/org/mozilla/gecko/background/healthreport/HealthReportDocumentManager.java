/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

package org.mozilla.gecko.background.healthreport;

import java.io.FileOutputStream;
import java.io.IOException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.Map.Entry;
import java.util.UUID;

import org.json.simple.JSONObject;
import org.mozilla.gecko.background.common.log.Logger;
import org.mozilla.gecko.sync.ExtendedJSONObject;
import org.mozilla.gecko.sync.NonObjectJSONException;
import org.mozilla.gecko.sync.Utils;

import android.annotation.SuppressLint;
import android.content.Context;
import android.content.SharedPreferences;

/**
 * Handles Health Report documents by providing document management after
 * documents have been generated by Gecko and Java.
 *
 * In Android implementation, this consists of merging the
 * Gecko- and Java-generated documents and upload handling.
 *
 * @author liuche
 *
 */
public class HealthReportDocumentManager {
  public static final String LOG_TAG = "HealthReportDocManager";

  private final String FHR_GECKO_DOCUMENT_PATH = "datareporting.healthreport.geckoDocument"; // TODO: placeholder - must be writeable from Gecko
  private final String FHR_ANDROID_DOCUMENT_PATH = "datareporting.healthreport.androidDocument";
  private final String FHR_MERGED_DOCUMENT_KEY = "datareporting.healthreport.mergedDocumenKey";

  private Context context;
  private SharedPreferences sharedPreferences;
  private AndroidHealthReporter androidHealthReporter;

  public HealthReportDocumentManager(Context context, String prefsFile) {
    this.context = context;
    this.androidHealthReporter = null;
  }

  /**
   * Checks that a merged document exists for upload, and if not, kicks off
   * the steps necessary to create one. Starts an upload if toUpload is
   * <code>true</code>
   *
   * @param toUpload boolean for whether to upload the document
   */
  public void ensureDocumentAndUpload(boolean toUpload) {
    String mergedDocumentPath = sharedPreferences.getString(FHR_MERGED_DOCUMENT_KEY, null);
    if (!documentIsRecent(mergedDocumentPath)) {
      // TODO: run on separate threads.
      ensureAndroidDocument();
      ensureGeckoDocument();
      // TODO: wait on both to return.
      mergeDocumentsAndWrite(FHR_GECKO_DOCUMENT_PATH, FHR_ANDROID_DOCUMENT_PATH);
    }
    if (toUpload) {
      startManagedDocumentUpload(null);
    }
  }

  private void ensureGeckoDocument() {
    if (!documentIsRecent(FHR_GECKO_DOCUMENT_PATH)) {
      // Start headless Gecko, start an FHR data collection + write.
    }
  }

  private void ensureAndroidDocument() {
    // TODO: shouldn't be limited to document written out - also payload in memory
    if (!documentIsRecent(FHR_ANDROID_DOCUMENT_PATH)) {
      // Launch Android data collection. Write out document.
      if (this.androidHealthReporter == null) {
        this.androidHealthReporter = new AndroidHealthReporter();
      }
      androidHealthReporter.collectAndObtainJSONPayload();
    }
  }

  /**
   * Returns whether the document at the path exists and is up to date.
   *
   * @param documentPath path to document to check for existence and recentness.
   * @return <code>true</code> if document exists and its generation date is within a
   * day, <code>false</code> otherwise.
   */
  private boolean documentIsRecent(String documentPath) {
    String document = Utils.readFile(context, documentPath);
    if (document == null) {
      return false;
    }

    String documentDate = null;
    try {
      ExtendedJSONObject documentJSON = new ExtendedJSONObject(document);
      documentDate = (String) documentJSON.get("thisPingDate");
    } catch (Exception e) {
      Logger.error(LOG_TAG, "Error parsing JSON document", e);
    }
    return isDateRecent(documentDate);
  }

  /**
   * Return true if documentDate qualifies as recent.
   *
   * @param documentDate date of document generation, in yyyy-MM-dd format
   * @return true if date represented by documentDate is within a day of current date.
   */
  @SuppressLint("SimpleDateFormat")
  private boolean isDateRecent(String documentDate) {
    if (documentDate == null) {
      return false;
    }

    SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");

    // Get date from yesterday.
    Calendar calendar = Calendar.getInstance();
    calendar.add(Calendar.DAY_OF_MONTH, -1);

    Date testDate;
    Date minDate;
    try {
      testDate = dateFormat.parse(documentDate);
      // Truncate to date granularity.
      minDate = dateFormat.parse(dateFormat.format(calendar.getTime()));
    } catch (ParseException e) {
      Logger.error(LOG_TAG, "Cannot parse document date", e);
      return false;
    }
    // Document date must not be before minimum date.
    return !testDate.before(minDate);
  }

  /**
   * Writes out a single document that merges FHR data from providers in Gecko and Android,
   * and assigns a GUID to that document.
   *
   * @param geckoDocumentPath
   *          file path for Gecko document
   * @param androidDocumentPath
   *          file path for Android document
   *
   * @return GUID for new document
   */
  public UUID mergeDocumentsAndWrite(String geckoDocumentPath, String androidDocumentPath) {
    // TODO: Assuming path passed in for now.
    if (geckoDocumentPath == null || androidDocumentPath == null) {
      Logger.error(LOG_TAG, "Missing document path.");
      return null;
    }

    String geckoDocument = Utils.readFile(context, geckoDocumentPath);
    String androidDocument = Utils.readFile(context, androidDocumentPath);
    ExtendedJSONObject geckoJSONObject;
    ExtendedJSONObject androidJSONObject;

    try {
      geckoJSONObject = new ExtendedJSONObject(geckoDocument);
      androidJSONObject = new ExtendedJSONObject(androidDocument);
    } catch (Exception e) {
      Logger.error(LOG_TAG, "Error in loading FHR document for merging.", e);
      return null;
    }

    try {
      mergeAndroidToGeckoReport(androidJSONObject, geckoJSONObject);
    } catch (NonObjectJSONException e) {
      Logger.error(LOG_TAG, "Error parsing JSON document.", e);
    }

    // Generate GUID.
    UUID uuid = UUID.randomUUID();

    // Write out new document.
    writeFile(uuid.toString(), geckoJSONObject.toJSONString());

    // Clean up the merged documents.
    context.deleteFile(geckoDocumentPath);
    context.deleteFile(androidDocumentPath);

    // Return GUID;
    return uuid;
  }

  public ExtendedJSONObject mergeAndroidToGeckoReport(ExtendedJSONObject androidObj, ExtendedJSONObject geckoObj) throws NonObjectJSONException {
    mergeAndroidToGeckoLast(androidObj, geckoObj);
    mergeAndroidToGeckoDays(androidObj, geckoObj);
    return geckoObj;
  }

  private void mergeAndroidToGeckoDays(ExtendedJSONObject androidObj, ExtendedJSONObject geckoObj) throws NonObjectJSONException {
    // We assume Gecko and Android providers do not collide on the "days" level.
    ExtendedJSONObject geckoDaysJSON = geckoObj.getObject("data").getObject("days");
    ExtendedJSONObject androidDaysJSON = androidObj.getObject("data").getObject("days");

    Iterable<Entry<String, Object>> androidDaysIterator = androidDaysJSON.entryIterable();
    for (Entry<String, Object> day : androidDaysIterator) {
      String dayKey = day.getKey();
      if (!geckoDaysJSON.containsKey(dayKey)) {
        geckoDaysJSON.put(dayKey, day.getValue());
      } else {
        // Entry already exists, so append Android entries to the day.
        ExtendedJSONObject geckoSingleDay = geckoDaysJSON.getObject(dayKey);
        ExtendedJSONObject androidSingleDayEntries = new ExtendedJSONObject((JSONObject) day.getValue());
        Iterable<Entry<String, Object>> dayEntriesIterator = androidSingleDayEntries.entryIterable();
        for (Entry<String, Object> dayEntry : dayEntriesIterator) {
          geckoSingleDay.put(dayEntry.getKey(), dayEntry.getValue());
        }
      }
    }
  }

  private void mergeAndroidToGeckoLast(ExtendedJSONObject androidObj, ExtendedJSONObject geckoObj) throws NonObjectJSONException {
    // We assume Gecko and Android providers do not collide on the "last" level.
    // TODO: do we care about the small chance of merging docs of two differing versions?
    ExtendedJSONObject geckoLastJSON = geckoObj.getObject("data").getObject("last");
    ExtendedJSONObject androidLastJSON = androidObj.getObject("data").getObject("last");

    Iterable<Entry<String, Object>> androidLastIterator = androidLastJSON.entryIterable();
    for (Entry<String, Object> e : androidLastIterator) {
      geckoLastJSON.put((String) e.getKey(), e.getValue());
    }
  }

  public boolean startManagedDocumentUpload(String payload) {
    // Check that policy has been accepted.
    // TODO: policy prefs must be mirrored to SharedPreferences.
    // TODO Auto-generated method stub
    return false;
  }

  private boolean writeFile(String filename, String contents) {
    FileOutputStream fos = null;
    try {
      fos = context.openFileOutput(filename, Context.MODE_PRIVATE);
      fos.write(contents.getBytes());
    } catch (Exception e) {
      return false;
    } finally {
      try {
        fos.close();
      } catch (IOException e) {
        // Ignore. Nothing we can do about it.
      }
    }
    return true;
  }
}