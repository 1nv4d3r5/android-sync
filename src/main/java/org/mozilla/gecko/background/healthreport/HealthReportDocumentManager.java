/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

package org.mozilla.gecko.background.healthreport;

import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Map.Entry;
import java.util.UUID;

import org.json.simple.JSONObject;
import org.mozilla.gecko.background.common.log.Logger;
import org.mozilla.gecko.sync.ExtendedJSONObject;
import org.mozilla.gecko.sync.NonObjectJSONException;
import org.mozilla.gecko.sync.Utils;

import android.content.Context;

/**
 * Handles Health Report documents by providing document management after
 * documents have been generated by Gecko and Java.
 *
 * In Android implementation, this consists of merging the
 * Gecko- and Java-generated documents and upload handling.
 *
 * @author liuche
 *
 */
public class HealthReportDocumentManager {
  public static final String LOG_TAG = "HealthReportDocManager";
  private Context context;
  private String prefsFile;

  public HealthReportDocumentManager(Context context, String prefsFile) {
    this.context = context;
    this.prefsFile = prefsFile;
  }

  /**
   * Writes out a single document that merges FHR data from providers in Gecko and Android,
   * and assigns a GUID to that document.
   *
   * @param geckoDocumentPath
   *          file path for Gecko document
   * @param androidDocumentPath
   *          file path for Android document
   *
   * @return GUID for new document
   */
  public UUID mergeDocumentsAndWrite(String geckoDocumentPath, String androidDocumentPath) {
    // TODO: Assuming path passed in for now.
    if (geckoDocumentPath == null || androidDocumentPath == null) {
      Logger.error(LOG_TAG, "Missing document path.");
      return null;
    }

    String geckoDocument = Utils.readFile(context, geckoDocumentPath);
    String androidDocument = Utils.readFile(context, androidDocumentPath);
    ExtendedJSONObject geckoJSONObject;
    ExtendedJSONObject androidJSONObject;

    try {
      geckoJSONObject = new ExtendedJSONObject(geckoDocument);
      androidJSONObject = new ExtendedJSONObject(androidDocument);
    } catch (Exception e) {
      Logger.error(LOG_TAG, "Error in loading FHR document for merging.", e);
      return null;
    }

    try {
      mergeAndroidToGeckoReport(androidJSONObject, geckoJSONObject);
    } catch (NonObjectJSONException e) {
      Logger.error(LOG_TAG, "Error parsing JSON document.", e);
    }

    // Generate GUID.
    UUID uuid = UUID.randomUUID();

    // Write out new document.
    writeFile(uuid.toString(), geckoJSONObject.toJSONString());

    // Clean up the merged documents.
    context.deleteFile(geckoDocumentPath);
    context.deleteFile(androidDocumentPath);

    // Return GUID;
    return uuid;
  }

  public ExtendedJSONObject mergeAndroidToGeckoReport(ExtendedJSONObject androidObj, ExtendedJSONObject geckoObj) throws NonObjectJSONException {
    mergeAndroidToGeckoLast(androidObj, geckoObj);
    mergeAndroidToGeckoDays(androidObj, geckoObj);
    return geckoObj;
  }

  private void mergeAndroidToGeckoDays(ExtendedJSONObject androidObj, ExtendedJSONObject geckoObj) throws NonObjectJSONException {
    // We assume Gecko and Android providers do not collide on the "days" level.
    ExtendedJSONObject geckoDaysJSON = geckoObj.getObject("data").getObject("days");
    ExtendedJSONObject androidDaysJSON = androidObj.getObject("data").getObject("days");

    Iterable<Entry<String, Object>> androidDaysIterator = androidDaysJSON.entryIterable();
    for (Entry<String, Object> day : androidDaysIterator) {
      String dayKey = day.getKey();
      if (!geckoDaysJSON.containsKey(dayKey)) {
        geckoDaysJSON.put(dayKey, day.getValue());
      } else {
        // Entry already exists, so append Android entries to the day.
        ExtendedJSONObject geckoSingleDay = geckoDaysJSON.getObject(dayKey);
        ExtendedJSONObject androidSingleDayEntries = new ExtendedJSONObject((JSONObject) day.getValue());
        Iterable<Entry<String, Object>> dayEntriesIterator = androidSingleDayEntries.entryIterable();
        for (Entry<String, Object> dayEntry : dayEntriesIterator) {
          geckoSingleDay.put(dayEntry.getKey(), dayEntry.getValue());
        }
      }
    }
  }

  private void mergeAndroidToGeckoLast(ExtendedJSONObject androidObj, ExtendedJSONObject geckoObj) throws NonObjectJSONException {
    // We assume Gecko and Android providers do not collide on the "last" level.
    ExtendedJSONObject geckoLastJSON = geckoObj.getObject("data").getObject("last");
    ExtendedJSONObject androidLastJSON = androidObj.getObject("data").getObject("last");

    Iterable<Entry<String, Object>> androidLastIterator = androidLastJSON.entryIterable();
    for (Entry<String, Object> e : androidLastIterator) {
      geckoLastJSON.put((String) e.getKey(), e.getValue());
    }
  }

  private boolean writeFile(String filename, String contents) {
    FileOutputStream fos = null;
    try {
      fos = context.openFileOutput(filename, Context.MODE_PRIVATE);
      fos.write(contents.getBytes());
    } catch (Exception e) {
      return false;
    } finally {
      try {
        fos.close();
      } catch (IOException e) {
        // Ignore. Nothing we can do about it.
      }
    }
    return true;
  }

  public boolean startManagedDocumentUpload(String payload) {
    // TODO Auto-generated method stub
    return false;
  }

}
